"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.Layout = void 0;
var React = require("react");
var DockLocation_1 = require("../DockLocation");
var DragDrop_1 = require("../DragDrop");
var Actions_1 = require("../model/Actions");
var SplitterNode_1 = require("../model/SplitterNode");
var TabNode_1 = require("../model/TabNode");
var TabSetNode_1 = require("../model/TabSetNode");
var Rect_1 = require("../Rect");
var Types_1 = require("../Types");
var BorderTabSet_1 = require("./BorderTabSet");
var Splitter_1 = require("./Splitter");
var Tab_1 = require("./Tab");
var TabSet_1 = require("./TabSet");
var FloatingWindow_1 = require("./FloatingWindow");
var FloatingWindowTab_1 = require("./FloatingWindowTab");
var TabFloating_1 = require("./TabFloating");
// Popout windows work in latest browsers based on webkit (Chrome, Opera, Safari, latest Edge) and Firefox. They do
// not work on any version if IE or the original Edge browser
// Assume any recent desktop browser not IE or original Edge will work
/** @hidden @internal */
// @ts-ignore
var isIEorEdge = typeof window !== "undefined" && (window.document.documentMode || /Edge\//.test(window.navigator.userAgent));
/** @hidden @internal */
var isDesktop = typeof window !== "undefined" && window.matchMedia && window.matchMedia("(hover: hover) and (pointer: fine)").matches;
/** @hidden @internal */
var defaultSupportsPopout = isDesktop && !isIEorEdge;
/**
 * A React component that hosts a multi-tabbed layout
 */
var Layout = /** @class */ (function (_super) {
    __extends(Layout, _super);
    function Layout(props) {
        var _this = _super.call(this, props) || this;
        /** @hidden @internal */
        _this.firstMove = false;
        /** @hidden @internal */
        _this.dragDivText = "";
        /** @hidden @internal */
        _this.onModelChange = function () {
            _this.forceUpdate();
            if (_this.props.onModelChange) {
                _this.props.onModelChange(_this.props.model);
            }
        };
        /** @hidden @internal */
        _this.updateRect = function () {
            var domRect = _this.getDomRect();
            var rect = new Rect_1.default(0, 0, domRect.width, domRect.height);
            if (!rect.equals(_this.state.rect) && rect.width !== 0 && rect.height !== 0) {
                _this.setState({ rect: rect });
            }
        };
        /** @hidden @internal */
        _this.updateLayoutMetrics = function () {
            if (_this.findHeaderBarSizeRef.current) {
                var headerBarSize = _this.findHeaderBarSizeRef.current.getBoundingClientRect().height;
                if (headerBarSize !== _this.state.calculatedHeaderBarSize) {
                    _this.setState({ calculatedHeaderBarSize: headerBarSize });
                }
            }
            if (_this.findTabBarSizeRef.current) {
                var tabBarSize = _this.findTabBarSizeRef.current.getBoundingClientRect().height;
                if (tabBarSize !== _this.state.calculatedTabBarSize) {
                    _this.setState({ calculatedTabBarSize: tabBarSize });
                }
            }
            if (_this.findBorderBarSizeRef.current) {
                var borderBarSize = _this.findBorderBarSizeRef.current.getBoundingClientRect().height;
                if (borderBarSize !== _this.state.calculatedBorderBarSize) {
                    _this.setState({ calculatedBorderBarSize: borderBarSize });
                }
            }
        };
        /** @hidden @internal */
        _this.getClassName = function (defaultClassName) {
            if (_this.props.classNameMapper === undefined) {
                return defaultClassName;
            }
            else {
                return _this.props.classNameMapper(defaultClassName);
            }
        };
        /** @hidden @internal */
        _this.onCloseWindow = function (id) {
            _this.doAction(Actions_1.default.unFloatTab(id));
            try {
                _this.props.model.getNodeById(id)._setWindow(undefined);
            }
            catch (e) {
                // catch incase it was a model change
            }
        };
        /** @hidden @internal */
        _this.onSetWindow = function (id, window) {
            _this.props.model.getNodeById(id)._setWindow(window);
        };
        /** @hidden @internal */
        _this.onCancelAdd = function () {
            var rootdiv = _this.selfRef.current;
            rootdiv.removeChild(_this.dragDiv);
            _this.dragDiv = undefined;
            if (_this.fnNewNodeDropped != null) {
                _this.fnNewNodeDropped();
                _this.fnNewNodeDropped = undefined;
            }
            DragDrop_1.default.instance.hideGlass();
            _this.newTabJson = undefined;
        };
        /** @hidden @internal */
        _this.onCancelDrag = function (wasDragging) {
            if (wasDragging) {
                var rootdiv = _this.selfRef.current;
                try {
                    rootdiv.removeChild(_this.outlineDiv);
                }
                catch (e) { }
                try {
                    rootdiv.removeChild(_this.dragDiv);
                }
                catch (e) { }
                _this.dragDiv = undefined;
                _this.hideEdges(rootdiv);
                if (_this.fnNewNodeDropped != null) {
                    _this.fnNewNodeDropped();
                    _this.fnNewNodeDropped = undefined;
                }
                DragDrop_1.default.instance.hideGlass();
                _this.newTabJson = undefined;
            }
        };
        /** @hidden @internal */
        _this.onDragDivMouseDown = function (event) {
            event.preventDefault();
            _this.dragStart(event, _this.dragDivText, TabNode_1.default._fromJson(_this.newTabJson, _this.props.model, false), true, undefined, undefined);
        };
        /** @hidden @internal */
        _this.dragStart = function (event, dragDivText, node, allowDrag, onClick, onDoubleClick) {
            if (_this.props.model.getMaximizedTabset() !== undefined || !allowDrag) {
                DragDrop_1.default.instance.startDrag(event, undefined, undefined, undefined, undefined, onClick, onDoubleClick, _this.currentDocument, _this.selfRef.current);
            }
            else {
                _this.dragNode = node;
                _this.dragDivText = dragDivText;
                DragDrop_1.default.instance.startDrag(event, _this.onDragStart, _this.onDragMove, _this.onDragEnd, _this.onCancelDrag, onClick, onDoubleClick, _this.currentDocument, _this.selfRef.current);
            }
        };
        /** @hidden @internal */
        _this.onDragStart = function () {
            _this.dropInfo = undefined;
            var rootdiv = _this.selfRef.current;
            _this.outlineDiv = _this.currentDocument.createElement("div");
            _this.outlineDiv.className = _this.getClassName(Types_1.CLASSES.FLEXLAYOUT__OUTLINE_RECT);
            _this.outlineDiv.style.visibility = "hidden";
            rootdiv.appendChild(_this.outlineDiv);
            if (_this.dragDiv == null) {
                _this.dragDiv = _this.currentDocument.createElement("div");
                _this.dragDiv.className = _this.getClassName(Types_1.CLASSES.FLEXLAYOUT__DRAG_RECT);
                _this.dragDiv.innerHTML = _this.dragDivText;
                rootdiv.appendChild(_this.dragDiv);
            }
            // add edge indicators
            _this.showEdges(rootdiv);
            if (_this.dragNode !== undefined && _this.dragNode instanceof TabNode_1.default && _this.dragNode.getTabRect() !== undefined) {
                _this.dragNode.getTabRect().positionElement(_this.outlineDiv);
            }
            _this.firstMove = true;
            return true;
        };
        /** @hidden @internal */
        _this.onDragMove = function (event) {
            if (_this.firstMove === false) {
                var speed = _this.props.model._getAttribute("tabDragSpeed");
                _this.outlineDiv.style.transition = "top " + speed + "s, left " + speed + "s, width " + speed + "s, height " + speed + "s";
            }
            _this.firstMove = false;
            var clientRect = _this.selfRef.current.getBoundingClientRect();
            var pos = {
                x: event.clientX - clientRect.left,
                y: event.clientY - clientRect.top,
            };
            _this.dragDiv.style.left = pos.x - _this.dragDiv.getBoundingClientRect().width / 2 + "px";
            _this.dragDiv.style.top = pos.y + 5 + "px";
            var dropInfo = _this.props.model._findDropTargetNode(_this.dragNode, pos.x, pos.y);
            if (dropInfo) {
                _this.dropInfo = dropInfo;
                _this.outlineDiv.className = _this.getClassName(dropInfo.className);
                dropInfo.rect.positionElement(_this.outlineDiv);
                _this.outlineDiv.style.visibility = "visible";
            }
        };
        /** @hidden @internal */
        _this.onDragEnd = function (event) {
            var rootdiv = _this.selfRef.current;
            rootdiv.removeChild(_this.outlineDiv);
            rootdiv.removeChild(_this.dragDiv);
            _this.dragDiv = undefined;
            _this.hideEdges(rootdiv);
            DragDrop_1.default.instance.hideGlass();
            if (_this.dropInfo) {
                if (_this.newTabJson !== undefined) {
                    var newNode = _this.doAction(Actions_1.default.addNode(_this.newTabJson, _this.dropInfo.node.getId(), _this.dropInfo.location, _this.dropInfo.index));
                    if (_this.fnNewNodeDropped != null) {
                        _this.fnNewNodeDropped(newNode, event);
                        _this.fnNewNodeDropped = undefined;
                    }
                    _this.newTabJson = undefined;
                }
                else if (_this.dragNode !== undefined) {
                    _this.doAction(Actions_1.default.moveNode(_this.dragNode.getId(), _this.dropInfo.node.getId(), _this.dropInfo.location, _this.dropInfo.index));
                }
            }
        };
        _this.props.model._setChangeListener(_this.onModelChange);
        _this.tabIds = [];
        _this.selfRef = React.createRef();
        _this.findHeaderBarSizeRef = React.createRef();
        _this.findTabBarSizeRef = React.createRef();
        _this.findBorderBarSizeRef = React.createRef();
        _this.supportsPopout = props.supportsPopout !== undefined ? props.supportsPopout : defaultSupportsPopout;
        _this.popoutURL = props.popoutURL ? props.popoutURL : "popout.html";
        // For backwards compatibility, prop closeIcon sets prop icons.close:
        _this.icons = props.closeIcon ? Object.assign({ close: props.closeIcon }, props.icons) : props.icons;
        _this.firstRender = true;
        _this.state = { rect: new Rect_1.default(0, 0, 0, 0), calculatedHeaderBarSize: 25, calculatedTabBarSize: 26, calculatedBorderBarSize: 30 };
        _this.onDragEnter = _this.onDragEnter.bind(_this);
        return _this;
    }
    /** @hidden @internal */
    Layout.prototype.styleFont = function (style) {
        if (this.props.font) {
            if (this.props.font.size) {
                style.fontSize = this.props.font.size;
            }
            if (this.props.font.family) {
                style.fontFamily = this.props.font.family;
            }
            if (this.props.font.style) {
                style.fontStyle = this.props.font.style;
            }
            if (this.props.font.weight) {
                style.fontWeight = this.props.font.weight;
            }
        }
        return style;
    };
    /** @hidden @internal */
    Layout.prototype.doAction = function (action) {
        if (this.props.onAction !== undefined) {
            var outcome = this.props.onAction(action);
            if (outcome !== undefined) {
                return this.props.model.doAction(outcome);
            }
            return undefined;
        }
        else {
            return this.props.model.doAction(action);
        }
    };
    /** @hidden @internal */
    Layout.prototype.componentDidMount = function () {
        this.updateRect();
        this.updateLayoutMetrics();
        // need to re-render if size changes
        this.currentDocument = this.selfRef.current.ownerDocument;
        this.currentWindow = this.currentDocument.defaultView;
        this.currentWindow.addEventListener("resize", this.updateRect);
    };
    /** @hidden @internal */
    Layout.prototype.componentDidUpdate = function () {
        this.updateRect();
        this.updateLayoutMetrics();
        if (this.props.model !== this.previousModel) {
            if (this.previousModel !== undefined) {
                this.previousModel._setChangeListener(undefined); // stop listening to old model
            }
            this.props.model._setChangeListener(this.onModelChange);
            this.previousModel = this.props.model;
        }
        // console.log("Layout time: " + this.layoutTime + "ms Render time: " + (Date.now() - this.start) + "ms");
    };
    /** @hidden @internal */
    Layout.prototype.getCurrentDocument = function () {
        return this.currentDocument;
    };
    /** @hidden @internal */
    Layout.prototype.getDomRect = function () {
        return this.selfRef.current.getBoundingClientRect();
    };
    /** @hidden @internal */
    Layout.prototype.getRootDiv = function () {
        return this.selfRef.current;
    };
    /** @hidden @internal */
    Layout.prototype.isSupportsPopout = function () {
        return this.supportsPopout;
    };
    /** @hidden @internal */
    Layout.prototype.getPopoutURL = function () {
        return this.popoutURL;
    };
    /** @hidden @internal */
    Layout.prototype.componentWillUnmount = function () {
        this.currentWindow.removeEventListener("resize", this.updateRect);
    };
    /** @hidden @internal */
    Layout.prototype.render = function () {
        var _this = this;
        // first render will be used to find the size (via selfRef)
        if (this.firstRender) {
            this.firstRender = false;
            return (React.createElement("div", { ref: this.selfRef, className: this.getClassName(Types_1.CLASSES.FLEXLAYOUT__LAYOUT) }, this.metricsElements()));
        }
        this.props.model._setPointerFine(window && window.matchMedia && window.matchMedia("(pointer: fine)").matches);
        // this.start = Date.now();
        var borderComponents = [];
        var tabSetComponents = [];
        var floatingWindows = [];
        var tabComponents = {};
        var splitterComponents = [];
        var metrics = {
            headerBarSize: this.state.calculatedHeaderBarSize,
            tabBarSize: this.state.calculatedTabBarSize,
            borderBarSize: this.state.calculatedBorderBarSize,
        };
        this.centerRect = this.props.model._layout(this.state.rect, metrics);
        this.renderBorder(this.props.model.getBorderSet(), borderComponents, tabComponents, floatingWindows, splitterComponents);
        this.renderChildren(this.props.model.getRoot(), tabSetComponents, tabComponents, floatingWindows, splitterComponents);
        var nextTopIds = [];
        var nextTopIdsMap = {};
        // Keep any previous tabs in the same DOM order as before, removing any that have been deleted
        this.tabIds.forEach(function (t) {
            if (tabComponents[t]) {
                nextTopIds.push(t);
                nextTopIdsMap[t] = t;
            }
        });
        this.tabIds = nextTopIds;
        // Add tabs that have been added to the DOM
        Object.keys(tabComponents).forEach(function (t) {
            if (!nextTopIdsMap[t]) {
                _this.tabIds.push(t);
            }
        });
        // this.layoutTime = (Date.now() - this.start);
        return (React.createElement("div", { ref: this.selfRef, className: this.getClassName(Types_1.CLASSES.FLEXLAYOUT__LAYOUT), onDragEnter: this.props.onExternalDrag ? this.onDragEnter : undefined },
            tabSetComponents,
            this.tabIds.map(function (t) {
                return tabComponents[t];
            }),
            borderComponents,
            splitterComponents,
            floatingWindows,
            this.metricsElements()));
    };
    /** @hidden @internal */
    Layout.prototype.metricsElements = function () {
        // used to measure the tab and border tab sizes
        var fontStyle = this.styleFont({ visibility: "hidden" });
        return (React.createElement(React.Fragment, null,
            React.createElement("div", { key: "findHeaderBarSize", ref: this.findHeaderBarSizeRef, style: fontStyle, className: this.getClassName(Types_1.CLASSES.FLEXLAYOUT__TABSET_HEADER_SIZER) }, "FindHeaderBarSize"),
            React.createElement("div", { key: "findTabBarSize", ref: this.findTabBarSizeRef, style: fontStyle, className: this.getClassName(Types_1.CLASSES.FLEXLAYOUT__TABSET_SIZER) }, "FindTabBarSize"),
            React.createElement("div", { key: "findBorderBarSize", ref: this.findBorderBarSizeRef, style: fontStyle, className: this.getClassName(Types_1.CLASSES.FLEXLAYOUT__BORDER_SIZER) }, "FindBorderBarSize")));
    };
    /** @hidden @internal */
    Layout.prototype.renderBorder = function (borderSet, borderComponents, tabComponents, floatingWindows, splitterComponents) {
        for (var _i = 0, _a = borderSet.getBorders(); _i < _a.length; _i++) {
            var border = _a[_i];
            if (border.isShowing()) {
                borderComponents.push(React.createElement(BorderTabSet_1.BorderTabSet, { key: "border_" + border.getLocation().getName(), border: border, layout: this, iconFactory: this.props.iconFactory, titleFactory: this.props.titleFactory, icons: this.icons }));
                var drawChildren = border._getDrawChildren();
                var i = 0;
                for (var _b = 0, drawChildren_1 = drawChildren; _b < drawChildren_1.length; _b++) {
                    var child = drawChildren_1[_b];
                    if (child instanceof SplitterNode_1.default) {
                        splitterComponents.push(React.createElement(Splitter_1.Splitter, { key: child.getId(), layout: this, node: child }));
                    }
                    else if (child instanceof TabNode_1.default) {
                        if (this.supportsPopout && child.isFloating()) {
                            var rect = this._getScreenRect(child);
                            floatingWindows.push(React.createElement(FloatingWindow_1.FloatingWindow, { key: child.getId(), url: this.popoutURL, rect: rect, title: child.getName(), id: child.getId(), onSetWindow: this.onSetWindow, onCloseWindow: this.onCloseWindow },
                                React.createElement(FloatingWindowTab_1.FloatingWindowTab, { layout: this, node: child, factory: this.props.factory })));
                            tabComponents[child.getId()] = React.createElement(TabFloating_1.TabFloating, { key: child.getId(), layout: this, node: child, selected: i === border.getSelected() });
                        }
                        else {
                            tabComponents[child.getId()] = React.createElement(Tab_1.Tab, { key: child.getId(), layout: this, node: child, selected: i === border.getSelected(), factory: this.props.factory });
                        }
                    }
                    i++;
                }
            }
        }
    };
    /** @hidden @internal */
    Layout.prototype.renderChildren = function (node, tabSetComponents, tabComponents, floatingWindows, splitterComponents) {
        var drawChildren = node._getDrawChildren();
        for (var _i = 0, _a = drawChildren; _i < _a.length; _i++) {
            var child = _a[_i];
            if (child instanceof SplitterNode_1.default) {
                splitterComponents.push(React.createElement(Splitter_1.Splitter, { key: child.getId(), layout: this, node: child }));
            }
            else if (child instanceof TabSetNode_1.default) {
                tabSetComponents.push(React.createElement(TabSet_1.TabSet, { key: child.getId(), layout: this, node: child, iconFactory: this.props.iconFactory, titleFactory: this.props.titleFactory, icons: this.icons }));
                this.renderChildren(child, tabSetComponents, tabComponents, floatingWindows, splitterComponents);
            }
            else if (child instanceof TabNode_1.default) {
                var selectedTab = child.getParent().getChildren()[child.getParent().getSelected()];
                if (selectedTab === undefined) {
                    // this should not happen!
                    console.warn("undefined selectedTab should not happen");
                }
                if (this.supportsPopout && child.isFloating()) {
                    var rect = this._getScreenRect(child);
                    floatingWindows.push(React.createElement(FloatingWindow_1.FloatingWindow, { key: child.getId(), url: this.popoutURL, rect: rect, title: child.getName(), id: child.getId(), onSetWindow: this.onSetWindow, onCloseWindow: this.onCloseWindow },
                        React.createElement(FloatingWindowTab_1.FloatingWindowTab, { layout: this, node: child, factory: this.props.factory })));
                    tabComponents[child.getId()] = React.createElement(TabFloating_1.TabFloating, { key: child.getId(), layout: this, node: child, selected: child === selectedTab });
                }
                else {
                    tabComponents[child.getId()] = React.createElement(Tab_1.Tab, { key: child.getId(), layout: this, node: child, selected: child === selectedTab, factory: this.props.factory });
                }
            }
            else {
                // is row
                this.renderChildren(child, tabSetComponents, tabComponents, floatingWindows, splitterComponents);
            }
        }
    };
    /** @hidden @internal */
    Layout.prototype._getScreenRect = function (node) {
        var rect = node.getRect().clone();
        var bodyRect = this.selfRef.current.getBoundingClientRect();
        var navHeight = Math.min(80, this.currentWindow.outerHeight - this.currentWindow.innerHeight);
        var navWidth = Math.min(80, this.currentWindow.outerWidth - this.currentWindow.innerWidth);
        rect.x = rect.x + bodyRect.x + this.currentWindow.screenX + navWidth;
        rect.y = rect.y + bodyRect.y + this.currentWindow.screenY + navHeight;
        return rect;
    };
    /**
     * Adds a new tab to the given tabset
     * @param tabsetId the id of the tabset where the new tab will be added
     * @param json the json for the new tab node
     */
    Layout.prototype.addTabToTabSet = function (tabsetId, json) {
        var tabsetNode = this.props.model.getNodeById(tabsetId);
        if (tabsetNode !== undefined) {
            this.doAction(Actions_1.default.addNode(json, tabsetId, DockLocation_1.default.CENTER, -1));
        }
    };
    /**
     * Adds a new tab to the active tabset (if there is one)
     * @param json the json for the new tab node
     */
    Layout.prototype.addTabToActiveTabSet = function (json) {
        var tabsetNode = this.props.model.getActiveTabset();
        if (tabsetNode !== undefined) {
            this.doAction(Actions_1.default.addNode(json, tabsetNode.getId(), DockLocation_1.default.CENTER, -1));
        }
    };
    /**
     * Adds a new tab by dragging a labeled panel to the drop location, dragging starts immediatelly
     * @param dragText the text to show on the drag panel
     * @param json the json for the new tab node
     * @param onDrop a callback to call when the drag is complete
     */
    Layout.prototype.addTabWithDragAndDrop = function (dragText, json, onDrop) {
        this.fnNewNodeDropped = onDrop;
        this.newTabJson = json;
        this.dragStart(undefined, dragText, TabNode_1.default._fromJson(json, this.props.model, false), true, undefined, undefined);
    };
    /**
     * Adds a new tab by dragging a labeled panel to the drop location, dragging starts when you
     * mouse down on the panel
     *
     * @param dragText the text to show on the drag panel
     * @param json the json for the new tab node
     * @param onDrop a callback to call when the drag is complete
     */
    Layout.prototype.addTabWithDragAndDropIndirect = function (dragText, json, onDrop) {
        this.fnNewNodeDropped = onDrop;
        this.newTabJson = json;
        DragDrop_1.default.instance.addGlass(this.onCancelAdd);
        this.dragDivText = dragText;
        this.dragDiv = this.currentDocument.createElement("div");
        this.dragDiv.className = this.getClassName("flexlayout__drag_rect");
        this.dragDiv.innerHTML = this.dragDivText;
        this.dragDiv.addEventListener("mousedown", this.onDragDivMouseDown);
        this.dragDiv.addEventListener("touchstart", this.onDragDivMouseDown);
        var r = new Rect_1.default(10, 10, 150, 50);
        r.centerInRect(this.state.rect);
        this.dragDiv.style.left = r.x + "px";
        this.dragDiv.style.top = r.y + "px";
        var rootdiv = this.selfRef.current;
        rootdiv.appendChild(this.dragDiv);
    };
    /** @hidden @internal */
    Layout.prototype.onDragEnter = function (event) {
        // DragDrop keeps track of number of dragenters minus the number of
        // dragleaves. Only start a new drag if there isn't one already.
        if (DragDrop_1.default.instance.isDragging())
            return;
        var drag = this.props.onExternalDrag(event);
        if (drag) {
            // Mimic addTabWithDragAndDrop, but pass in DragEvent
            this.fnNewNodeDropped = drag.onDrop;
            this.newTabJson = drag.json;
            this.dragStart(event, drag.dragText, TabNode_1.default._fromJson(drag.json, this.props.model, false), true, undefined, undefined);
        }
    };
    /** @hidden @internal */
    Layout.prototype.showEdges = function (rootdiv) {
        if (this.props.model.isEnableEdgeDock()) {
            var domRect = rootdiv.getBoundingClientRect();
            var r = this.centerRect;
            var size = 100;
            var length_1 = size + "px";
            var radius = "50px";
            var width = "10px";
            this.edgeTopDiv = this.currentDocument.createElement("div");
            this.edgeTopDiv.className = this.getClassName(Types_1.CLASSES.FLEXLAYOUT__EDGE_RECT);
            this.edgeTopDiv.style.top = r.y + "px";
            this.edgeTopDiv.style.left = r.x + (r.width - size) / 2 + "px";
            this.edgeTopDiv.style.width = length_1;
            this.edgeTopDiv.style.height = width;
            this.edgeTopDiv.style.borderBottomLeftRadius = radius;
            this.edgeTopDiv.style.borderBottomRightRadius = radius;
            this.edgeLeftDiv = this.currentDocument.createElement("div");
            this.edgeLeftDiv.className = this.getClassName(Types_1.CLASSES.FLEXLAYOUT__EDGE_RECT);
            this.edgeLeftDiv.style.top = r.y + (r.height - size) / 2 + "px";
            this.edgeLeftDiv.style.left = r.x + "px";
            this.edgeLeftDiv.style.width = width;
            this.edgeLeftDiv.style.height = length_1;
            this.edgeLeftDiv.style.borderTopRightRadius = radius;
            this.edgeLeftDiv.style.borderBottomRightRadius = radius;
            this.edgeBottomDiv = this.currentDocument.createElement("div");
            this.edgeBottomDiv.className = this.getClassName(Types_1.CLASSES.FLEXLAYOUT__EDGE_RECT);
            this.edgeBottomDiv.style.bottom = domRect.height - r.getBottom() + "px";
            this.edgeBottomDiv.style.left = r.x + (r.width - size) / 2 + "px";
            this.edgeBottomDiv.style.width = length_1;
            this.edgeBottomDiv.style.height = width;
            this.edgeBottomDiv.style.borderTopLeftRadius = radius;
            this.edgeBottomDiv.style.borderTopRightRadius = radius;
            this.edgeRightDiv = this.currentDocument.createElement("div");
            this.edgeRightDiv.className = this.getClassName(Types_1.CLASSES.FLEXLAYOUT__EDGE_RECT);
            this.edgeRightDiv.style.top = r.y + (r.height - size) / 2 + "px";
            this.edgeRightDiv.style.right = domRect.width - r.getRight() + "px";
            this.edgeRightDiv.style.width = width;
            this.edgeRightDiv.style.height = length_1;
            this.edgeRightDiv.style.borderTopLeftRadius = radius;
            this.edgeRightDiv.style.borderBottomLeftRadius = radius;
            rootdiv.appendChild(this.edgeTopDiv);
            rootdiv.appendChild(this.edgeLeftDiv);
            rootdiv.appendChild(this.edgeBottomDiv);
            rootdiv.appendChild(this.edgeRightDiv);
        }
    };
    /** @hidden @internal */
    Layout.prototype.hideEdges = function (rootdiv) {
        if (this.props.model.isEnableEdgeDock()) {
            try {
                rootdiv.removeChild(this.edgeTopDiv);
                rootdiv.removeChild(this.edgeLeftDiv);
                rootdiv.removeChild(this.edgeBottomDiv);
                rootdiv.removeChild(this.edgeRightDiv);
            }
            catch (e) { }
        }
    };
    /** @hidden @internal */
    Layout.prototype.maximize = function (tabsetNode) {
        this.doAction(Actions_1.default.maximizeToggle(tabsetNode.getId()));
    };
    /** @hidden @internal */
    Layout.prototype.customizeTab = function (tabNode, renderValues) {
        if (this.props.onRenderTab) {
            this.props.onRenderTab(tabNode, renderValues);
        }
    };
    /** @hidden @internal */
    Layout.prototype.customizeTabSet = function (tabSetNode, renderValues) {
        if (this.props.onRenderTabSet) {
            this.props.onRenderTabSet(tabSetNode, renderValues);
        }
    };
    /** @hidden @internal */
    Layout.prototype.i18nName = function (id, param) {
        var message;
        if (this.props.i18nMapper) {
            message = this.props.i18nMapper(id, param);
        }
        if (message === undefined) {
            message = id + (param === undefined ? "" : param);
        }
        return message;
    };
    return Layout;
}(React.Component));
exports.Layout = Layout;
exports.default = Layout;
//# sourceMappingURL=Layout.js.map